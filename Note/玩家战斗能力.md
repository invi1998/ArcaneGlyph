# Roll 翻滚

首先，我们需要给玩家控制角色添加翻滚能力，翻滚操作我们拟定用`空格键`触发，但是对于翻滚操作来说，单纯按空格是没有意义的，因为翻滚需要一个朝向，这个朝向就由移动按键提供。

即，我们的翻滚操作需要一个前置操作，就是角色移动操作，在UE5增强输入中，这个Action是由一个叫做`弦操作（Chorded Action）`来提供的，他能将这两个操作拟合到一起。

![image-20250226001048802](.\image-20250226001048802.png)



## 获取最后的移动输入（确定翻滚的方向）

修正翻滚方向，我们通过在蒙太奇起始帧添加MotionWarping实现，设置如下。

![image-20250226122602997](.\image-20250226122602997.png)

然后，回到翻滚能力，我们需要从输入中获取最后一次运动输入，来确定我们的方向，记得将结果归一化。

![image-20250226122837809](.\image-20250226122837809.png)

然后我们给运动扭曲组件添加扭曲方向，记得参数要和蒙太奇里的字符串匹配。同时切记，这里我们不能直接将得到的输入方向传递给运动扭曲，因为这个只是一个方向向量，而运动扭曲需要的是一个旋转，所以我们需要MakeRotFromX处理，即**以该方向为前向（X轴）的标准旋转**

![image-20250226122951759](.\image-20250226122951759.png)

然后记得在播放蒙太奇之前，先提前把扭曲方向确定。

![image-20250226124349335](.\image-20250226124349335.png)

在 Unreal Engine 中，**运动扭曲（Motion Warping）** 的 `AddOrUpdateWarpTargetFromLocationAndRotation` 节点需要传递 **目标旋转（TargetRotation）** 而非直接的方向向量，这涉及到底层动画系统和运动学计算的本质区别。以下是详细解释：

---

### **1. 方向向量与旋转的本质区别**
- **方向向量（Direction Vector）**：  
  仅表示 **运动方向**（如 `(X, Y, Z)` 的归一化向量），但无法描述角色在三维空间中的 **完整朝向**（如绕垂直轴旋转的角度）。
  
- **旋转（Rotation）**：  
  通过 `FRotator` 或 `FQuat` 完整定义角色在三维空间中的 **朝向信息**（包括偏航 Yaw、俯仰 Pitch、滚动 Roll），是运动扭曲调整根运动的核心参数。

---

### **2. 为什么需要 `MakeRotFromX`？**
#### **原因 1：运动扭曲需要完整的旋转信息**
运动扭曲的核心功能是 **动态修正动画的根运动**，使其适配目标位置和朝向。  
- 如果仅传递方向向量（如 `(1, 0, 0)`），系统无法确定角色 **绕垂直轴（Yaw）** 的具体旋转值。  
- 通过 `MakeRotFromX`，可以将方向向量转换为一个 **以该方向为前向（X轴）的标准旋转**，例如：  
  ```cpp
  // 方向向量 (1, 0, 0) → FRotator(0, 0, 0)
  // 方向向量 (0, 1, 0) → FRotator(0, 90, 0)
  FRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(Direction);
  ```
  这样，运动扭曲能明确知道角色需要以何种旋转完成动画。

#### **原因 2：动画根运动的旋转依赖**
翻滚动画通常包含 **根运动（Root Motion）**，其位移和旋转均由动画曲线驱动。  
- 若直接传递方向向量，运动扭曲无法正确计算动画播放过程中 **旋转的插值**（如从当前朝向平滑过渡到目标朝向）。  
- 通过传递 `TargetRotation`，运动扭曲会自动计算 **从当前旋转到目标旋转的插值路径**，确保动画流畅过渡。

---

### **3. 示例：翻滚方向修正**
假设角色需要向右侧翻滚（方向向量为 `(0, 1, 0)`）：  
1. **直接传递方向向量的问题**：  
   - 方向向量 `(0, 1, 0)` 仅表示横向移动，但角色可能仍然面朝原始方向（如 `(1, 0, 0)`）。  
   - 动画播放时，根运动的旋转未被正确修正，导致角色“横移”而非“面朝右侧翻滚”。

2. **使用 `MakeRotFromX` 的解决方案**：  
   ```cpp
   FRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(FVector(0, 1, 0));
   // TargetRotation.Yaw = 90°
   ```
   - 运动扭曲会将角色的 **前向（X轴）** 对齐到 `(0, 1, 0)` 方向（即右转 90°）。  
   - 翻滚动画的根运动会被重新映射到新朝向，角色会“面朝右侧”完成翻滚动作。

---

### **4. 技术验证：运动扭曲的工作流程**
1. **输入参数解析**：  
   - `Location`：目标位置（翻滚终点）。  
   - `Rotation`：目标旋转（翻滚完成时的角色朝向）。  

2. **动画修正过程**：  
   - 运动扭曲根据当前角色旋转和 `TargetRotation`，计算 **旋转差值**。  
   - 在动画播放过程中，根运动的位移和旋转会被动态修正，使角色从当前位置/朝向 **平滑过渡** 到目标位置/朝向。

---

### **5. 常见误区与解决方案**
#### **误区：方向向量直接控制旋转**
- **错误假设**：认为方向向量可以直接替代旋转，导致角色朝向未对齐。  
- **解决方案**：始终通过 `MakeRotFromX/Y/Z` 或 `FindLookAtRotation` 将方向向量转换为旋转。

#### **误区：忽略垂直轴（Z轴）的影响**
- **问题**：若角色在斜坡上翻滚，仅用水平方向向量会导致旋转不匹配地形法线。  
- **解决方案**：使用 `MakeRotFromXZ` 结合地面法线，生成适配地形的旋转。

---

### **6. 代码示例**
```cpp
// 获取角色输入方向（如摇杆输入）
FVector InputDirection = GetMovementComponent()->GetLastInputVector().GetSafeNormal();

// 将方向转换为目标旋转
FRotator TargetRotation = UKismetMathLibrary::MakeRotFromX(InputDirection);

// 设置运动扭曲目标
UMotionWarpingComponent* MotionWarping = FindComponentByClass<UMotionWarpingComponent>();
MotionWarping->AddOrUpdateWarpTargetFromLocationAndRotation(
    TEXT("RollTarget"), 
    TargetLocation, 
    TargetRotation
);
```

---

### **总结**
- **方向向量**仅描述移动方向，**旋转**描述完整的三维朝向。  
- 运动扭曲需要通过 `TargetRotation` 确定动画根运动的旋转修正路径。  
- `MakeRotFromX` 是将方向向量转换为角色前向旋转的标准方法，确保动画朝向与移动方向一致。



## 滚动距离

上面我们已经实现了滚动触发，滚动方向控制，现在，还缺少滚动距离控制，因为我们目前的滚动完全是基于动画根骨骼的运动距离。因此，为了动态计算距离，我们可以利用另一种运动扭曲和状态通知。

