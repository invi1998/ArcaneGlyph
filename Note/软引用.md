在Unreal Engine 5中，**软引用（Soft References）**和**硬引用（Hard References）**是管理资源加载的核心机制，直接影响内存占用和运行时性能。以下是详细解析：

---

### **1. 硬引用（Hard References）**
#### **定义**
- 硬引用直接关联目标资产，当父资产加载时，硬引用的所有依赖资产会**同步加载到内存**。
- 例如：在蓝图中将材质直接拖放到Static Mesh组件中，或通过C++代码直接包含头文件引用。

#### **优点**
- **访问速度快**：资源已预加载，使用时无需额外操作。
- **代码简单**：无需手动管理资源加载逻辑。

#### **缺点**
- **内存占用高**：所有引用资源在父资源加载时全部驻留内存。
- **启动时间长**：大量硬引用会导致初始加载时间增加。

#### **何时使用**
- **核心资源**：如玩家角色模型、基础UI材质、常用音效等。
- **高频使用资源**：需要频繁访问且不可卸载的资产。

---

### **2. 软引用（Soft References）**
#### **定义**
- 软引用通过**路径字符串**（如`TSoftObjectPtr<UObject>`）间接指向资产，资源不会自动加载，需手动调用`LoadAsset()`或异步加载（`AsyncLoad`）。
- 例如：通过蓝图节点“Async Load Asset from Soft Object Reference”动态加载资源。

#### **优点**
- **按需加载**：仅在需要时加载资源，减少内存占用。
- **灵活管理**：适合动态场景（如开放世界流送）。

#### **缺点**
- **运行时开销**：加载资源可能引发卡顿（需异步优化）。
- **代码复杂度**：需处理加载状态和错误回调。

#### **何时使用**
- **低频资源**：如特定关卡的贴图、支线任务道具。
- **动态内容**：根据玩家行为加载的资源（如皮肤、武器库）。

---

### **3. 蓝图中的类型转换（Cast）**
#### **用途**
- 检查对象是否属于特定类，并安全访问其属性和方法。
- 例如：判断碰撞体是否为玩家角色，以触发特定逻辑。

#### **注意事项**
- **性能影响**：频繁Cast（尤其是每帧执行）可能影响性能。
- **替代方案**：优先使用**接口（Interfaces）**或**事件分发器（Event Dispatchers）**，减少类型耦合。

#### **优化技巧**
- **提前过滤**：使用`IsA`节点快速判断类关系，再执行Cast。
- **缓存结果**：避免重复Cast同一对象。

---

### **4. 综合对比表**
| **特性**       | **硬引用**           | **软引用**                |
| -------------- | -------------------- | ------------------------- |
| **加载时机**   | 父资源加载时同步加载 | 手动按需加载（同步/异步） |
| **内存占用**   | 高                   | 低                        |
| **适用场景**   | 核心/高频资源        | 动态/低频资源             |
| **代码复杂度** | 低                   | 中高（需处理加载逻辑）    |

---

### **5. 实战建议**
- **硬引用**：用于保障核心体验的关键资源（如主角动画、基础物理材质）。
- **软引用**：结合**异步加载**实现无缝开放世界，或动态下载内容（如DLC）。
- **Cast**：仅在必要时使用，优先用接口解耦逻辑。例如：
  ```cpp
  // C++ 示例：使用接口替代Cast
  if (Actor->Implements<UDamageable>()) {
      IDamageable::Execute_ApplyDamage(Actor, DamageAmount);
  }
  ```

通过合理选择引用方式和优化类型转换，可以在UE5项目中实现高效的内存管理和流畅的运行时性能。



# TObjectPtr

![image-20250206152937952](.\image-20250206152937952.png)

TObjectPtr 是 Unreal Engine 5 (UE5) 中引入的一种智能指针类型，旨在优化 UObject 类型对象的管理和垃圾回收。下面将详细介绍 TObjectPtr 的特性及其限制。

### 特性

1. **专为垃圾回收设计**：TObjectPtr 主要用于 UE5 的垃圾回收（Garbage Collection, GC）系统内管理的对象。它特别适用于那些需要被垃圾回收系统追踪的 UObject 及其派生类实例 。

2. **轻量级**：与传统的智能指针不同，TObjectPtr 不会增加对象的引用计数，这意味着它不会影响对象的生命周期管理。相反，它的主要作用是提供一种安全的方式来访问由 UE 垃圾回收系统管理的对象 。

3. **懒加载支持**：在编辑器模式下，TObjectPtr 支持懒加载（Lazy Loading），即只有当真正需要访问指向的对象时才会进行解析和加载。这有助于提高编辑器的加载速度和性能 。

4. **安全性**：TObjectPtr 提供了空指针检查和安全的对象访问机制，确保在尝试访问一个可能已被垃圾回收的对象时不会导致程序崩溃或未定义行为 。

5. **兼容性**：在非编辑器版本中，TObjectPtr 会自动转换为原始指针（UObject*），从而避免了额外的运行时开销 。

### 限制

1. **仅限于 UObject 类型**：TObjectPtr 专门设计用来指向 UObject 或其子类的对象，不能用于其他非 UObject 类型的数据 。也就是只能用在UOject类的成员变量里。

2. **不直接控制生命周期**：由于 TObjectPtr 不增加引用计数，它并不直接参与对象生命周期的管理。这意味着如果所有对某个对象的强引用都消失了，即使存在 TObjectPtr 指向该对象，对象仍然会被垃圾回收 。

3. **编辑器特定功能**：一些如懒加载等特性主要针对编辑器环境进行了优化，在打包后的游戏版本中，这些特性可能会失效或者退化成普通的 UObject 指针 。

4. **复杂性增加**：尽管 TObjectPtr 提供了许多便利，但其内部实现较为复杂，特别是涉及到对象的懒加载、指针解析等方面。这增加了开发者理解和调试代码的难度 。

通过上述分析可以看出，TObjectPtr 是一个强大的工具，它为 UE5 开发者提供了更高效和安全的方式来处理 UObject 对象。然而，开发者也需要注意其使用场景和限制，以充分发挥其优势并避免潜在的问题。例如，在多线程环境下使用时，需格外注意线程安全问题；同时，对于非 UObject 类型的数据，应选择合适的智能指针类型，如 TSharedPtr 或 TWeakPtr 。总之，合理利用 TObjectPtr 能够帮助开发者构建更加健壮和高效的虚幻引擎应用程序。



# TitleProperty

```c++
	// TitleProperty 被用来指定在编辑器中显示的属性，这里指定了 InputAction 属性作为显示的标题
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (TitleProperty = "InputAction"))
	TArray<FArcaneInputActionConfig> NativeInputActions;
```

![image-20250206175620711](.\image-20250206175620711.png)

改成InputTag后，可以看到，标题显示就为InputTag内容，这就是TitleProperty这个元属性的作用

```c++
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (TitleProperty = "InputTag"))
	TArray<FArcaneInputActionConfig> NativeInputActions;
```

![image-20250206184902297](.\image-20250206184902297.png)



# **`meta = (ExposeOnSpawn = "true")`**

在我们使用蓝图节点生成Spawn的时候（比如SpawnActorFromClass依据类名生成对象），如果我们希望在生成这个对象的时候给他同时传递一些我们自定义的参数进入，就可以使用该元属性，这样，在生成节点处就会多出一个输入引脚，用于让我们填充这个成员变量值。

比如下面这个，在我们生成弹丸对象的时候，希望同时给这个弹丸填充他的GameplayEffectSpecHandle信息，用于后续的伤害应用，就可以在弹丸C++类中这样做

```c++
	//meta = (ExposeOnSpawn = "true")
	//功能：在**生成（Spawn）**该Actor实例时，将变量暴露为可配置参数。
	//用途：在C++中调用SpawnActor时，可通过FActorSpawnParameters传递初始值。
	//在蓝图中生成该Actor时，生成节点（Spawn Actor）会自动添加一个输入引脚，允许直接设置ProjectileSpecHandle的初始值。
	UPROPERTY(BlueprintReadOnly, Category = "Projectile", meta = (ExposeOnSpawn = "true"))
	FGameplayEffectSpecHandle ProjectileSpecHandle;
```



![image-20250303005416677](.\image-20250303005416677.png)

在Unreal Engine的Actor类中添加成员变量`ProjectileSpecHandle`时，使用的`UPROPERTY`宏标记具有以下作用：

### 1. **`BlueprintReadOnly`**
   - **功能**：该标记使变量在**蓝图（Blueprints）中可见但不可修改**。
   - **用途**：允许蓝图读取`ProjectileSpecHandle`的值（例如用于逻辑判断或传递给其他函数），但无法直接修改它，确保值的控制权保留在C++代码中。

### 2. **`Category = "Projectile"`**
   - **功能**：在编辑器的**细节面板（Details Panel）**中将变量归类到“Projectile”组。
   - **用途**：提高代码可维护性和可读性，方便开发人员在项目中快速定位与抛射物相关的属性。

### 3. **`meta = (ExposeOnSpawn = "true")`**
   - **功能**：在**生成（Spawn）**该Actor实例时，将变量暴露为可配置参数。
   - **用途**：
     - 在C++中调用`SpawnActor`时，可通过`FActorSpawnParameters`传递初始值。
     - 在蓝图中生成该Actor时，生成节点（Spawn Actor）会自动添加一个输入引脚，允许直接设置`ProjectileSpecHandle`的初始值。

---

### **变量类型 `FGameplayEffectSpecHandle`**
- **作用**：用于Gameplay Ability System（GAS），表示一个`GameplayEffect`的实例句柄，通常用于定义抛射物命中目标时触发的游戏效果（如伤害、增益等）。
- **典型场景**：当抛射物击中目标时，通过`ProjectileSpecHandle`应用关联的`GameplayEffect`到目标角色。

---

### **注意事项**
1. **蓝图兼容性**：
   - `FGameplayEffectSpecHandle`是GAS的底层类型，可能无法直接在蓝图中创建或修改。通常需要通过C++或Gameplay Ability的上下文（如`AbilityTask`）生成并传递该句柄。

2. **复制（Replication）**：
   - 当前未标记`Replicated`，因此变量不会自动同步到客户端。若需多玩家同步，需添加`Replicated`并实现`GetLifetimeReplicatedProps`。

3. **初始化依赖**：
   - 由于`ExposeOnSpawn`的存在，生成该Actor时必须显式传递`ProjectileSpecHandle`的值，否则其内容可能为空或无效。

---

### **示例用法（C++中生成Actor）**
```cpp
// 创建GameplayEffectSpec
FGameplayEffectSpecHandle SpecHandle = AbilitySystemComponent->MakeOutgoingSpec(EffectClass, 1.0f, ContextHandle);

// 生成Actor并传递参数
FActorSpawnParameters SpawnParams;
SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

AProjectileActor* Projectile = GetWorld()->SpawnActor<AProjectileActor>(
    ProjectileClass,
    SpawnLocation,
    SpawnRotation,
    SpawnParams
);

// 设置ProjectileSpecHandle
if (Projectile) {
    Projectile->ProjectileSpecHandle = SpecHandle;
}
```

---

### **蓝图中的使用**
在蓝图中生成该Actor时，Spawn Actor节点会显示`ProjectileSpecHandle`作为输入参数，但通常需要通过C++或Gameplay Ability传递有效值，因为蓝图可能无法直接构造`FGameplayEffectSpecHandle`。

![蓝图Spawn节点示例](https://docs.unrealengine.com/Images/Programming/UnrealArchitecture/Actors/Spawning/HowToSpawnAnActorInBlueprint.webp)

---

### **总结**
此`UPROPERTY`配置适用于需在抛射物生成时动态注入`GameplayEffect`逻辑的场景（如不同技能生成不同效果的抛射物），结合GAS实现灵活的游戏能力系统。
