在Unreal Engine 5中，**软引用（Soft References）**和**硬引用（Hard References）**是管理资源加载的核心机制，直接影响内存占用和运行时性能。以下是详细解析：

---

### **1. 硬引用（Hard References）**
#### **定义**
- 硬引用直接关联目标资产，当父资产加载时，硬引用的所有依赖资产会**同步加载到内存**。
- 例如：在蓝图中将材质直接拖放到Static Mesh组件中，或通过C++代码直接包含头文件引用。

#### **优点**
- **访问速度快**：资源已预加载，使用时无需额外操作。
- **代码简单**：无需手动管理资源加载逻辑。

#### **缺点**
- **内存占用高**：所有引用资源在父资源加载时全部驻留内存。
- **启动时间长**：大量硬引用会导致初始加载时间增加。

#### **何时使用**
- **核心资源**：如玩家角色模型、基础UI材质、常用音效等。
- **高频使用资源**：需要频繁访问且不可卸载的资产。

---

### **2. 软引用（Soft References）**
#### **定义**
- 软引用通过**路径字符串**（如`TSoftObjectPtr<UObject>`）间接指向资产，资源不会自动加载，需手动调用`LoadAsset()`或异步加载（`AsyncLoad`）。
- 例如：通过蓝图节点“Async Load Asset from Soft Object Reference”动态加载资源。

#### **优点**
- **按需加载**：仅在需要时加载资源，减少内存占用。
- **灵活管理**：适合动态场景（如开放世界流送）。

#### **缺点**
- **运行时开销**：加载资源可能引发卡顿（需异步优化）。
- **代码复杂度**：需处理加载状态和错误回调。

#### **何时使用**
- **低频资源**：如特定关卡的贴图、支线任务道具。
- **动态内容**：根据玩家行为加载的资源（如皮肤、武器库）。

---

### **3. 蓝图中的类型转换（Cast）**
#### **用途**
- 检查对象是否属于特定类，并安全访问其属性和方法。
- 例如：判断碰撞体是否为玩家角色，以触发特定逻辑。

#### **注意事项**
- **性能影响**：频繁Cast（尤其是每帧执行）可能影响性能。
- **替代方案**：优先使用**接口（Interfaces）**或**事件分发器（Event Dispatchers）**，减少类型耦合。

#### **优化技巧**
- **提前过滤**：使用`IsA`节点快速判断类关系，再执行Cast。
- **缓存结果**：避免重复Cast同一对象。

---

### **4. 综合对比表**
| **特性**       | **硬引用**           | **软引用**                |
| -------------- | -------------------- | ------------------------- |
| **加载时机**   | 父资源加载时同步加载 | 手动按需加载（同步/异步） |
| **内存占用**   | 高                   | 低                        |
| **适用场景**   | 核心/高频资源        | 动态/低频资源             |
| **代码复杂度** | 低                   | 中高（需处理加载逻辑）    |

---

### **5. 实战建议**
- **硬引用**：用于保障核心体验的关键资源（如主角动画、基础物理材质）。
- **软引用**：结合**异步加载**实现无缝开放世界，或动态下载内容（如DLC）。
- **Cast**：仅在必要时使用，优先用接口解耦逻辑。例如：
  ```cpp
  // C++ 示例：使用接口替代Cast
  if (Actor->Implements<UDamageable>()) {
      IDamageable::Execute_ApplyDamage(Actor, DamageAmount);
  }
  ```

通过合理选择引用方式和优化类型转换，可以在UE5项目中实现高效的内存管理和流畅的运行时性能。



# TObjectPtr

![image-20250206152937952](.\image-20250206152937952.png)

TObjectPtr 是 Unreal Engine 5 (UE5) 中引入的一种智能指针类型，旨在优化 UObject 类型对象的管理和垃圾回收。下面将详细介绍 TObjectPtr 的特性及其限制。

### 特性

1. **专为垃圾回收设计**：TObjectPtr 主要用于 UE5 的垃圾回收（Garbage Collection, GC）系统内管理的对象。它特别适用于那些需要被垃圾回收系统追踪的 UObject 及其派生类实例 。

2. **轻量级**：与传统的智能指针不同，TObjectPtr 不会增加对象的引用计数，这意味着它不会影响对象的生命周期管理。相反，它的主要作用是提供一种安全的方式来访问由 UE 垃圾回收系统管理的对象 。

3. **懒加载支持**：在编辑器模式下，TObjectPtr 支持懒加载（Lazy Loading），即只有当真正需要访问指向的对象时才会进行解析和加载。这有助于提高编辑器的加载速度和性能 。

4. **安全性**：TObjectPtr 提供了空指针检查和安全的对象访问机制，确保在尝试访问一个可能已被垃圾回收的对象时不会导致程序崩溃或未定义行为 。

5. **兼容性**：在非编辑器版本中，TObjectPtr 会自动转换为原始指针（UObject*），从而避免了额外的运行时开销 。

### 限制

1. **仅限于 UObject 类型**：TObjectPtr 专门设计用来指向 UObject 或其子类的对象，不能用于其他非 UObject 类型的数据 。也就是只能用在UOject类的成员变量里。

2. **不直接控制生命周期**：由于 TObjectPtr 不增加引用计数，它并不直接参与对象生命周期的管理。这意味着如果所有对某个对象的强引用都消失了，即使存在 TObjectPtr 指向该对象，对象仍然会被垃圾回收 。

3. **编辑器特定功能**：一些如懒加载等特性主要针对编辑器环境进行了优化，在打包后的游戏版本中，这些特性可能会失效或者退化成普通的 UObject 指针 。

4. **复杂性增加**：尽管 TObjectPtr 提供了许多便利，但其内部实现较为复杂，特别是涉及到对象的懒加载、指针解析等方面。这增加了开发者理解和调试代码的难度 。

通过上述分析可以看出，TObjectPtr 是一个强大的工具，它为 UE5 开发者提供了更高效和安全的方式来处理 UObject 对象。然而，开发者也需要注意其使用场景和限制，以充分发挥其优势并避免潜在的问题。例如，在多线程环境下使用时，需格外注意线程安全问题；同时，对于非 UObject 类型的数据，应选择合适的智能指针类型，如 TSharedPtr 或 TWeakPtr 。总之，合理利用 TObjectPtr 能够帮助开发者构建更加健壮和高效的虚幻引擎应用程序。



# TitleProperty

```c++
	// TitleProperty 被用来指定在编辑器中显示的属性，这里指定了 InputAction 属性作为显示的标题
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (TitleProperty = "InputAction"))
	TArray<FArcaneInputActionConfig> NativeInputActions;
```

![image-20250206175620711](.\image-20250206175620711.png)

改成InputTag后，可以看到，标题显示就为InputTag内容，这就是TitleProperty这个元属性的作用

```c++
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, meta = (TitleProperty = "InputTag"))
	TArray<FArcaneInputActionConfig> NativeInputActions;
```

![image-20250206184902297](.\image-20250206184902297.png)



# **`meta = (ExposeOnSpawn = "true")`**

在我们使用蓝图节点生成Spawn的时候（比如SpawnActorFromClass依据类名生成对象），如果我们希望在生成这个对象的时候给他同时传递一些我们自定义的参数进入，就可以使用该元属性，这样，在生成节点处就会多出一个输入引脚，用于让我们填充这个成员变量值。

比如下面这个，在我们生成弹丸对象的时候，希望同时给这个弹丸填充他的GameplayEffectSpecHandle信息，用于后续的伤害应用，就可以在弹丸C++类中这样做

```c++
	//meta = (ExposeOnSpawn = "true")
	//功能：在**生成（Spawn）**该Actor实例时，将变量暴露为可配置参数。
	//用途：在C++中调用SpawnActor时，可通过FActorSpawnParameters传递初始值。
	//在蓝图中生成该Actor时，生成节点（Spawn Actor）会自动添加一个输入引脚，允许直接设置ProjectileSpecHandle的初始值。
	UPROPERTY(BlueprintReadOnly, Category = "Projectile", meta = (ExposeOnSpawn = "true"))
	FGameplayEffectSpecHandle ProjectileSpecHandle;
```



![image-20250303005416677](.\image-20250303005416677.png)

在Unreal Engine的Actor类中添加成员变量`ProjectileSpecHandle`时，使用的`UPROPERTY`宏标记具有以下作用：

### 1. **`BlueprintReadOnly`**
   - **功能**：该标记使变量在**蓝图（Blueprints）中可见但不可修改**。
   - **用途**：允许蓝图读取`ProjectileSpecHandle`的值（例如用于逻辑判断或传递给其他函数），但无法直接修改它，确保值的控制权保留在C++代码中。

### 2. **`Category = "Projectile"`**
   - **功能**：在编辑器的**细节面板（Details Panel）**中将变量归类到“Projectile”组。
   - **用途**：提高代码可维护性和可读性，方便开发人员在项目中快速定位与抛射物相关的属性。

### 3. **`meta = (ExposeOnSpawn = "true")`**
   - **功能**：在**生成（Spawn）**该Actor实例时，将变量暴露为可配置参数。
   - **用途**：
     - 在C++中调用`SpawnActor`时，可通过`FActorSpawnParameters`传递初始值。
     - 在蓝图中生成该Actor时，生成节点（Spawn Actor）会自动添加一个输入引脚，允许直接设置`ProjectileSpecHandle`的初始值。

---

### **变量类型 `FGameplayEffectSpecHandle`**
- **作用**：用于Gameplay Ability System（GAS），表示一个`GameplayEffect`的实例句柄，通常用于定义抛射物命中目标时触发的游戏效果（如伤害、增益等）。
- **典型场景**：当抛射物击中目标时，通过`ProjectileSpecHandle`应用关联的`GameplayEffect`到目标角色。

---

### **注意事项**
1. **蓝图兼容性**：
   - `FGameplayEffectSpecHandle`是GAS的底层类型，可能无法直接在蓝图中创建或修改。通常需要通过C++或Gameplay Ability的上下文（如`AbilityTask`）生成并传递该句柄。

2. **复制（Replication）**：
   - 当前未标记`Replicated`，因此变量不会自动同步到客户端。若需多玩家同步，需添加`Replicated`并实现`GetLifetimeReplicatedProps`。

3. **初始化依赖**：
   - 由于`ExposeOnSpawn`的存在，生成该Actor时必须显式传递`ProjectileSpecHandle`的值，否则其内容可能为空或无效。

---

### **示例用法（C++中生成Actor）**
```cpp
// 创建GameplayEffectSpec
FGameplayEffectSpecHandle SpecHandle = AbilitySystemComponent->MakeOutgoingSpec(EffectClass, 1.0f, ContextHandle);

// 生成Actor并传递参数
FActorSpawnParameters SpawnParams;
SpawnParams.SpawnCollisionHandlingOverride = ESpawnActorCollisionHandlingMethod::AlwaysSpawn;

AProjectileActor* Projectile = GetWorld()->SpawnActor<AProjectileActor>(
    ProjectileClass,
    SpawnLocation,
    SpawnRotation,
    SpawnParams
);

// 设置ProjectileSpecHandle
if (Projectile) {
    Projectile->ProjectileSpecHandle = SpecHandle;
}
```

---

### **蓝图中的使用**
在蓝图中生成该Actor时，Spawn Actor节点会显示`ProjectileSpecHandle`作为输入参数，但通常需要通过C++或Gameplay Ability传递有效值，因为蓝图可能无法直接构造`FGameplayEffectSpecHandle`。

---

### **总结**
此`UPROPERTY`配置适用于需在抛射物生成时动态注入`GameplayEffect`逻辑的场景（如不同技能生成不同效果的抛射物），结合GAS实现灵活的游戏能力系统。



# PostEditChangeProperty

以往我们将某个碰撞盒子附着到骨骼上，只能通过启动游戏，查看编辑附着属性，其实可以通过PostEditChangeProperty函数实现，在编辑状态下调整附着到骨骼的碰撞盒子

![image-20250303234040165](.\image-20250303234040165.png)

```c++
#if WITH_EDITOR
void AArcaneEnemyCharacter::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	Super::PostEditChangeProperty(PropertyChangedEvent);

	// 如果修改了左手碰撞盒的骨骼名称，那么需要重新将碰撞盒附加到新的骨骼上
	if (PropertyChangedEvent.GetMemberPropertyName() == GET_MEMBER_NAME_CHECKED(AArcaneEnemyCharacter, LeftHandCollisionBoxAttachBoneName))
	{
		LeftHandCollisionBox->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetIncludingScale, LeftHandCollisionBoxAttachBoneName);
	}

	if (PropertyChangedEvent.GetMemberPropertyName() == GET_MEMBER_NAME_CHECKED(AArcaneEnemyCharacter, RightHandCollisionBoxAttachBoneName))
	{
		RightHandCollisionBox->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetIncludingScale, RightHandCollisionBoxAttachBoneName);
	}

	if (PropertyChangedEvent.GetMemberPropertyName() == GET_MEMBER_NAME_CHECKED(AArcaneEnemyCharacter, HeadCollisionBoxAttachBoneName))
	{
		HeadCollisionBox->AttachToComponent(GetMesh(), FAttachmentTransformRules::SnapToTargetIncludingScale, HeadCollisionBoxAttachBoneName);
	}
}
#endif
```



这段代码是Unreal Engine 5中`AArcaneEnemyCharacter`类的`PostEditChangeProperty`函数实现，主要用于在编辑器环境下响应属性变化并执行相应逻辑。以下是对该函数及其应用场景的详细解析：

---

### **一、代码结构解析**
1. **条件编译指令**
   ```cpp
   #if WITH_EDITOR
   ...
   #endif
   ```
   - 此代码仅在编辑器编译时生效，避免在最终发布的游戏版本中包含编辑器专用逻辑。

2. **函数定义**
   ```cpp
   void AArcaneEnemyCharacter::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
   ```
   - 继承自`AActor`的虚函数，用于在编辑器中某个属性被修改后触发。

3. **父类调用**
   ```cpp
   Super::PostEditChangeProperty(PropertyChangedEvent);
   ```
   - 确保父类的属性修改逻辑（如组件更新、蓝图刷新等）正常执行。

4. **属性检查与响应**
   - 通过`PropertyChangedEvent.GetMemberPropertyName()`检测被修改的属性名称。
   - 若修改的是`LeftHandCollisionBoxAttachBoneName`、`RightHandCollisionBoxAttachBoneName`或`HeadCollisionBoxAttachBoneName`，则重新将对应的碰撞盒组件（`LeftHandCollisionBox`等）附加到骨骼上。

---

### **二、PostEditChangeProperty 函数的作用**
#### 1. **核心功能**
- **属性修改响应**  
  当用户在编辑器（如Details面板）中修改对象的属性值时，此函数会被自动调用，允许开发者编写自定义逻辑以响应属性变化。

#### 2. **代码中的具体行为**
- **动态更新碰撞盒位置**  
  如果用户修改了碰撞盒绑定的骨骼名称（`AttachBoneName`），立即将碰撞盒重新附加到新的骨骼上，确保编辑器中的修改实时生效。

#### 3. **关键参数**
- **FPropertyChangedEvent**  
  包含被修改属性的元数据（如属性名称、旧值、新值等），用于判断需要响应哪些属性变化。

---

### **三、应用场景**
#### 1. **实时同步编辑器修改**
- **示例场景**  
  在角色编辑时，设计者可能需要调整碰撞盒绑定的骨骼（例如从左手换到右手）。通过`PostEditChangeProperty`，修改骨骼名称后，碰撞盒会自动跟随新骨骼，无需手动重启编辑器或重新运行游戏。

#### 2. **数据验证与修复**
- **示例场景**  
  若某个属性依赖其他属性（如设置技能范围时不能超过最大距离），可在此函数中检查并自动修正非法值。

#### 3. **复杂逻辑触发**
- **示例场景**  
  修改角色的初始生命值后，自动更新血条UI组件的初始状态；修改光照颜色后，立即刷新场景预览。

#### 4. **资源重新加载**
- **示例场景**  
  修改材质引用后，自动重新加载材质并应用到模型上。

---

### **四、代码中的关键细节**
1. **GET_MEMBER_NAME_CHECKED 宏**  
   - 用于安全获取类成员变量的名称字符串，避免硬编码错误。
   - 例如：`GET_MEMBER_NAME_CHECKED(AArcaneEnemyCharacter, LeftHandCollisionBoxAttachBoneName)` 返回字符串`"LeftHandCollisionBoxAttachBoneName"`。

2. **AttachToComponent**  
   - 将碰撞盒附加到骨骼时使用的`FAttachmentTransformRules::SnapToTargetIncludingScale`规则，表示立即将碰撞盒对齐到目标骨骼的位置、旋转和缩放。

3. **编辑器专用逻辑**  
   - 由于涉及编辑器操作（如Details面板属性修改），代码通过`WITH_EDITOR`宏保护，避免在非编辑器构建中包含冗余逻辑。

---

### **五、潜在改进方向**
1. **批量属性检查**  
   可将多个属性名称的检查合并为`switch-case`或`TArray`遍历，提升代码可维护性。

2. **错误处理**  
   添加对骨骼是否存在、碰撞盒是否有效的检查，避免因无效输入导致崩溃。

3. **性能优化**  
   若频繁修改属性（如滑动数值条），可通过延迟更新或脏标记（Dirty Flag）减少实时计算开销。

---

### **六、总结**
`PostEditChangeProperty`是UE编辑器环境下响应属性修改的核心函数，通过结合`FPropertyChangedEvent`，开发者可以实现高效的编辑器交互逻辑。在此代码中，它用于确保碰撞盒与骨骼的实时同步，是编辑器工具链开发中不可或缺的组成部分。
